export const metadata = {
  title: "How Evolu Works",
  description: "Learn how Evolu works under the hood.",
};

export const sections = [];

<Warn>
  This doc is from an earlier version of Evolu. While some concepts still apply,
  others may have changed — double-check with the latest source or tests.
</Warn>

# How Evolu works?

Evolu is simple. That's the feature, not a bug. It's based on James Long's[ CRDTs for Mortals](https://www.youtube.com/watch?v=DEcwa68f-jY) talk. I recommend you to watch it. James also made a [working example](https://github.com/jlongster/crdt-example-app), and someone very well [explained it](https://github.com/steida/crdt-example-app_annotated/blob/master/NOTES.md). I took that code and improved it for production.

So, how does Evolu work?

Evolu creates a SQLite database on the user’s device and stores all data locally. While reads are handled with full SQL, writes must follow a specific format to safely sync across devices—without merge conflicts. Every change to the database is described as a **CRDT message**.

<Note>
  CRDT stands for "Conflict-Free Replicated Data Type." It’s a type of data
  structure used in distributed computing and databases to allow concurrent
  updates without conflicts or centralized coordination. CRDTs are ideal for
  scenarios where multiple replicas of data exist and can be updated
  independently and concurrently.
</Note>

Evolu stores these CRDT messages locally and derives the actual database state from them. The simplest and currently only mutation strategy is **last-write-wins**. Each CRDT message contains a table name, row ID, column name, value, and a timestamp. Timestamps are critical for ensuring a globally consistent order of operations, and Evolu uses [Hybrid Logical Clocks](https://jaredforsyth.com/posts/hybrid-logical-clocks/) for this.

## How it really works?

Everything begins with a mutation—creating or updating a row:

```tsx
const { insert, update } = useMutation();

const result = insert("todo", { title, isCompleted: false });

if (result.ok) {
  update("todo", { id: result.value.id, isCompleted: true });
}
```

Evolu uses queueMicrotask to queue an array of Mutation objects, which are sent as a batch to a Web Worker, preventing any main thread blocking.

```ts
export type MutationKind = "insert" | "update" | "upsert";

export type Mutation<S extends EvoluSchema, Kind extends MutationKind> = <
  TableName extends keyof S,
>(
  table: TableName,
  props: InferInput<ObjectType<MutationMapping<S[TableName], Kind>>>,
  options?: MutationOptions,
) => Result<
  { readonly id: S[TableName]["id"]["Type"] },
  | ValidMutationSizeError
  | MergeObjectTypeErrors<ObjectType<MutationMapping<S[TableName], Kind>>>
>;
```

Inside the Web Worker, each `Mutation` is converted into a `CrdtMessage`.

```ts
/**
 * A CRDT (Conflict-free Replicated Data Type) message that combines a unique
 * {@link Timestamp} with a {@link DbChange}.
 */
export interface CrdtMessage {
  readonly timestamp: Timestamp;
  readonly change: DbChange;
}

/**
 * A DbChange is a change to a table row. Together with a unique
 * {@link Timestamp}, it forms a {@link CrdtMessage}.
 */
export interface DbChange {
  readonly table: TableName;
  readonly id: Id;
  readonly values: ReadonlyRecord<ColumnName, SqliteValue>;
}
```

Every `CrdtMessage` will get a `Timestamp` consisting of `NodeId`, `Millis`, and `Counter`.

```ts
export const Timestamp = object({
  millis: Millis,
  counter: Counter,
  nodeId: NodeId,
});
```

Timestamps ensure consistent ordering across devices and must be unique. This is achieved using the NodeId and Counter. Since system clocks can be unreliable (e.g., going backward), Evolu handles this by choosing the later time and incrementing the counter. The logic lives in the sendTimestamp function. The latest timestamp is stored in the database to generate new ones.

Now we have an array of messages ready to be applied to the local database using applyMessages. This same function is used for both local mutations and messages received from other devices, ensuring consistency.

In `Db.ts`, the `applyMessages` function:

- Stores messages in a separate table
- Applies them to the main database (if new)
- Follows a last-write-wins strategy
- Updates the Merkle tree

The Merkle tree helps determine the last shared state between local and remote devices. It’s implemented as a "merkleized" prefix tree (trie).

Once messages are applied, the sync loop is triggered and any subscribed queries are refreshed.

The sync loop continues comparing Merkle trees until both devices reach the same state. Incoming timestamps are handled via `receiveTimestamp`.

And that’s it.

Take a look at the [source code](https://github.com/evoluhq/evolu), [API Reference](/docs/api-reference), and the tests to dive deeper.
